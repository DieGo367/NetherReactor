description In-game splits for the Nether Reactor Core Challenge!
icon speedrun.png


namespace minecraft
tag functions load [nrcc:load]
tag functions tick [nrcc:tick]

namespace nrcc
objective NRCCGlobal

@runner = @a[tag=Runner]
@armors = @e[type=!:armor_stand]

@blocks = @e[type=!:armor_stand,tag=GuiseBlock]

macro set_msg takes msg run $time_printer.PreMsg = (msg)
enum BAR CHAT TITLE

define core 501
define core_active 502
define core_dead 503

define Dimensions [!:overworld, !:the_nether, !:the_end]
define DimIDs [0, 1, 2]
define DimNames ["Overworld", "Nether", "End"]
define DimColors ["green", "red", "dark_purple"]

function load {
	.score
	.scoredelete Splits
	.score Splits
	.score Health health
	# scoreboard objectives setdisplay sidebar Splits

	tag @a remove Runner

	# UI
	.define startButton {
		"text": "[Start]",
		"color": "green",
		"clickEvent": {
			"action": "run_command",
			"value": "/function ~:start"
		},
		"hoverEvent": {
			"action": "show_text",
			"contents": {
				"text": "Click to start the run!"
			}
		}
	}
	tellraw @a (startButton)
}
function tick {
	> with @runner run .lambda {
		# Increase timer
		Time/Splits ++

		# Countdown titles
		> if Time/Splits == -60 run title @s title {"text":"3"}
		> if Time/Splits == -40 run title @s title {"text":"2"}
		> if Time/Splits == -20 run title @s title {"text":"1"}
		> if Time/Splits == 0 run title @s title {"text":"GO!","color":"gold"}

		# in run
		> if Time/Splits >= 0 run .lambda {
			# print timer
			.call print_time Time/Splits (BAR)

			# Dimension check
			.call check_dim
			Temp = CurrDim
			Temp -= LastDim
			> unless Temp == 0 run .lambda {
				KnownDim = 0
				.for ID in (DimIDs) {
					> if CurrDim == (ID) {
						.macro set_msg "{\"text\": \"The ((DimNames[(ID)]))\", \"color\": \"((DimColors[(ID)]))\"}"
						KnownDim = 1
					}
				}
				> if KnownDim == 0 run .macro set_msg "{\"text\": \"Custom Dimension\", \"color\": \"gray\"}"
				LastDim = CurrDim
				.call split
			}
			Temp reset

			# Item check
			> if HasCore == 0 {
				> if @s[nbt={Inventory:[{tag:{CustomModelData:(core)}}]}] run .lambda {
					.macro set_msg "{\"text\": \"Core get\"}"
					.call split
					HasCore = 1
				}
			}

			# Activation check
			> if Activated == 0 {
				> if @blocks[nbt={ArmorItems:[{tag:{CustomModelData:(core_active)}}]}] run .lambda {
					.macro set_msg "{\"text\": \"Activated\"}"
					.call split
					Activated = 1
				}
			}

			# Death check
			> if Activated == 1 {
				> if @s/Health == 0 run .lambda {
					title @s title {"text": "You failed...", "color": "red"}
					.macro set_msg "{\"text\": \"Failed\", \"color\": \"red\"}"
					.call print_time Time/Splits (CHAT)
					.call stop
				}
			}

			# Finish check
			> if @blocks[nbt={ArmorItems:[{tag:{CustomModelData:(core_dead)}}]}] run .lambda {
				title @s title {"text": "Time!","color": "gold"}
				.macro set_msg "{\"text\": \"Time!\",\"color\": \"gold\"}"
				.call print_time Time/Splits (CHAT)
				.call stop
			}
		}
	}
}

function start {
	tag @a remove Runner
	tag @s add Runner

	effect give @s !:slowness 3 255
	effect give @s !:mining_fatigue 3 255
	
	.scoredelete Splits
	.score Splits
	# scoreboard objectives setdisplay sidebar Splits
	Time/Splits = -61
	SplitCount = 0
	.call check_dim
	LastDim = CurrDim
	HasCore = 0
	Activated = 0
	WarnLoc/NetherReactorVar = (CHAT)
}

function stop {
	tag @a remove Runner
	WarnLoc/NetherReactorVar = (BAR)
}

function check_dim {
	.for Dim in (Dimensions) index i {
		> in (Dim) as @p[distance=..0] run CurrDim = (i)
	}
}

function split {
	SplitCount ++
	.eval SplitNums range(0, 1001)
	.for N in (SplitNums) {
		> if SplitCount == (N) {
			scoreboard players operation (N): Splits = Time Splits
		}
	}
	.call print_time Time/Splits (CHAT)
}

function calc_time takes Value {
	# Get minutes
	Minutes = Value
	Scalar = 1200
	Minutes /= Scalar
	Subtractor = Minutes
	Subtractor *= Scalar
	Value -= Subtractor
	# Get seconds
	Seconds = Value
	Scalar = 20
	Seconds /= Scalar
	Subtractor = Seconds
	Subtractor *= Scalar
	Value -= Subtractor
	# Get sub seconds
	Scalar = 5
	Value *= Scalar
	# cleanup
	Scalar reset
	Subtractor reset
}
function print_time takes Value PrintLoc {
	.do calc_time

	# update suffixes
	> if Seconds < 10 run $time_printer.SecMark = ":0"
	> unless Seconds < 10 run $time_printer.SecMark = ":"
	> if Value < 10 run $time_printer.SubSecMark = ":0"
	> unless Value < 10 run $time_printer.SubSecMark = ":"
	> if $time_printer.PreMsg run $time_printer.PreMsgMark = ": "
	> unless $time_printer.PreMsg {
		$time_printer.PreMsgMark = ""
		$time_printer.PreMsg = ""
	}

	.define timeText {
		"text": "",
		"color": "aqua",
		"extra": [
			{"storage": "~:time_printer", "nbt": "PreMsg", "interpret": true},
			{"storage": "~:time_printer", "nbt": "PreMsgMark"},
			{"score": {
				"name": "Minutes",
				"objective": "NRCCGlobal"
			}},
			{"storage": "~:time_printer", "nbt": "SecMark"},
			{"score": {
				"name": "Seconds",
				"objective": "NRCCGlobal"
			}},
			{"storage": "~:time_printer", "nbt": "SubSecMark"},
			{"score":{
				"name": "Value",
				"objective": "NRCCGlobal"
			}}
		]
	}

	# print
	> if PrintLoc == (BAR) run title @s actionbar (timeText)
	> if PrintLoc == (TITLE) run title @s title (timeText)
	> if PrintLoc == (CHAT) run tellraw @s (timeText)

	# cleanup
	$time_printer.PreMsg remove
}