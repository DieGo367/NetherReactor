pack Adds the Nether Reactor from early versions of Minecraft: Pocket Edition
icon nether_reactor

namespace minecraft
tag functions load [nether_reactor:init]
tag functions tick [nether_reactor:tick]


namespace nether_reactor
nameglobals NetherReactorVar

tag blocks air [minecraft:air,minecraft:cave_air]

define @nearest @e[limit=1,sort=nearest]
define @item @e[type=$:item]
define @decayer @item[nbt={Item:{tag:{decayer:1b}}}]
define @diamonds @item[nbt={Item:{id:"minecraft:diamond",Count:3b}}]
define @irons @item[nbt={Item:{id:"minecraft:iron_ingot",Count:6b}}]
define @reactors @e[type=$:shulker,tag=NetherReactorCore]
define @blocks @e[type=$:armor_stand,tag=NetherReactorCustomBlock]

define setWarnMsg data modify storage ~:warn msg set value
enum BAR CHAT TITLE

list BlockIDs 1 2 3 4
list BlockNames core core_active core_dead glowing_obsidian
map BlockID maps (BlockNames) to (BlockIDs)
list SourceBlocks $:spawner $:spawner $:spawner $:crying_obsidian
map SourceBlock maps (BlockNames) to (SourceBlocks)
list SourceItems $:diamond_ore $:diamond_ore $:diamond_ore $:crying_obsidian
map SourceItem maps (BlockNames) to (SourceItems)
list PlaceScores PlacedDiamondOre PlacedDiamondOre PlacedDiamondOre PlacedCryingObs
map PlaceScore maps (BlockNames) to (PlaceScores)
list Cores core core_active core_dead

function init {
	.scoredef
	.score WarnLoc = (BAR)
	# core 
	.scoredef Y
	.scoredef Reaction
	.scoredef InvulnTime
	.scoredef Looking
	.scoredef LookedAt
	# player
		# block placement
		.scoredef SearchTime
		.scoredef Raytrace
		.scoredef HeldBlockID
		.scoredef PlacedDiamondOre minecraft.used:minecraft.diamond_ore
		.scoredef PlacedCryingObs minecraft.used:minecraft.crying_obsidian
		# block use
		.scoredef IsInRange
		.scoredef WasInRange
		.scoredef Sneaking minecraft.custom:minecraft.sneak_time
		.scoredef BlockMine minecraft.custom:minecraft.damage_dealt
		.scoredef BlockUse minecraft.custom:minecraft.talked_to_villager
}

function tick {
	# crafting recipe
	execute as @diamonds at @s {
		execute if block ~ ~-1 ~ minecraft:crafting_table {
			execute if entity @irons[distance=..1] run .call craft
		}
	}

	# block mask deletion
	execute as @blocks at @s {
		execute if block ~~~ #~:air run {
			.call core/disable_click
			kill @s
		}
	}

	# right clicker logic
	execute as @e[type=$:villager,tag=RightClicker] at @s {
		# kill clickers that are missing a block and have not just spawned
		execute unless entity @s[tag=JustSpawned] if block ~ ~1.5 ~ #~:air run tp @s ~ ~-1000 ~
	}
	execute as @e[type=$:villager,tag=RightClicker,tag=JustSpawned] at @s {
		# move clickers down to their block after having spawned for a tick
		tp @s ~ ~-1000 ~
		tag @s remove JustSpawned
	}

	# core looking detection
	.score @blocks.Looking = 0
	.score @a.IsInRange = 0
	execute as @blocks[nbt={ArmorItems:[{tag:{CustomModelData:(BlockID[core])}}]}] at @s run .lambda {
		# ask each nearby player to tally if they can see and right click the block
		tag @s add Target
		execute as @a[distance=..4,scores={Sneaking=0}] run .call player/look
		tag @s remove Target
	}
	execute as @blocks[scores={Looking=0}] at @s run {
		# if a block is not looked at, disable clickers
		.call core/disable_click
		.score @s.LookedAt = 0
	}
	execute as @blocks[scores={Looking=1..}] at @s run {
		# when a block starts to be looked at, enable clickers
		.unless @s.LookedAt == 1 run .call core/enable_click
		.score @s.LookedAt = 1
	}
	execute as @a {
		# if a player walks into range of a core, reset BlockMine to enable right click detection
		.if @s.IsInRange == 1 run .if @s.WasInRange == 0 {
			.score @s.BlockMine = 0
		}
		.score @s.WasInRange = @s.IsInRange
		.score @s.Sneaking = 0
	}
	
	# core placement detection
	.for Block in (BlockNames) {
		.define ID (BlockID[(Block)])
		.define Item (SourceItem[(Block)])
		execute as @a[nbt={SelectedItem:{id:"(Item)",tag:{CustomModelData:(ID)}}}] at @s run .lambda {
			.score @s.HeldBlockID = (ID)
			.call player/start_search
		}
	}
	execute as @a[tag=SearchingForCores] at @s run .call player/searching
	.eval UniqueScores '['+','.join(list(set("(PlaceScores)"[1:-1].split(','))))+']'
	.for Score in (UniqueScores) {
		.score @a.(Score) = 0
	}

	# core tick update
	execute as @reactors at @s run .call core/tick
	
	# infinite night
	.if IsInfiniteNight == 1 run .call infinite_night
}

in core {
	# as new reactor
	function init {
		tag @s add NetherReactorCore
		# prevent breaking during alignment
		effect give @s $:resistance 1 255 true
		.score @s.InvulnTime = 5
	}
	# as @blocks
	define VillagerOffset -1.449
	function enable_click {
		.json VillagerData {
			"NoAI": true,
			"Silent": true,
			"Tags": ["RightClicker", "JustSpawned"],
			"ActiveEffects": [
				{"Id": 10, "Amplifier": 3, "Duration": 2147483647, "ShowParticles": false},
				{"Id": 14, "Amplifier": 0, "Duration": 2147483647, "ShowParticles": false}
			]
		}
		execute positioned ~ ~(VillagerOffset) ~ {
			.define mag 0.202
			.list pos -(mag) (mag)
			.for X in (pos) {
				.for Z in (pos) {
					summon $:villager ~(X) ~1000 ~(Z) (VillagerData)
				}
			}
		}
	}
	function disable_click {
		execute positioned ~ ~(VillagerOffset) ~ run tp @e[type=$:villager,tag=RightClicker,distance=..0.5] ~ ~-1000 ~
	}
	# as @reactors
	function tick {
		# Starting invulnerability
		.if @s.InvulnTime == 1 run effect clear @s
		.if @s.InvulnTime > 0 run .score @s.InvulnTime --
		# Shulker took damage
		execute unless entity @s[nbt={"Health":30f}] run .call core/damage
		# Run reaction logic
		execute if entity @s[tag=Active] run .call core/reaction
	}
	function damage {
		data modify entity @s Health set value 30
		.define @target @p[distance=..6]
		tag @a remove HasPickaxe 

		execute as @target run .call player/check_pickaxe
		execute if entity @target[tag=HasPickaxe] run .call core/break
		execute if entity @target unless entity @target[tag=HasPickaxe] {
			execute unless entity @s[tag=Active] unless entity @s[tag=Dead] run .call core/activation_check
		}
		
		tag @a remove HasPickaxe
	}
	function break {
		tag @s remove NetherReactorCore
		tag @s remove Active
		tag @s remove Dead
		tp @s ~ -1000 ~
		kill @s
		bossbar set ~:bossbar players
		execute as @p[distance=..6,tag=HasPickaxe] unless entity @s[gamemode=creative] {
			loot spawn ~~~ loot ~:core
		}
	}
	function activation_check {
		.set @s.Y run data get entity @s Pos[1]
		.if @s.Y > 7 run .if @s.Y < 223 run .lambda {
			.call core/structure_check
			execute if entity @s[tag=IsValid] run .call core/start
			execute unless entity @s[tag=IsValid] run (setWarnMsg) "Not the correct pattern!"
		}
		.unless @s.Y > 7 run (setWarnMsg) "The nether reactor needs to be built lower down."
		.unless @s.Y < 223 run (setWarnMsg) "The nether reactor needs to be built higher up."
		
		execute if data storage ~:warn msg run .lambda {
			.if WarnLoc == (BAR) run title @p actionbar {"text":"","extra":[{"storage":"~:warn","nbt":"msg"}]}
			.if WarnLoc == (TITLE) run title @p title {"text":"","extra":[{"storage":"~:warn","nbt":"msg"}]}
			.if WarnLoc == (CHAT) run tellraw @p {"text":"","extra":[{"storage":"~:warn","nbt":"msg"}]}
			data remove storage ~:warn msg
		}
	}
	function summon_mark {
		# summon $:armor_stand ~~~ {NoGravity:true}
		effect give @e[type=$:armor_stand,limit=1,sort=nearest] $:glowing 100
	}
	function structure_check {
		tag @s add IsValid
		.define invalidate tag @s remove IsValid

		# 4 gold corners
		.for X in [-1,1] {
			.for Z in [-1,1] {
				execute unless block ~(X) ~-1 ~(Z) $:gold_block run (invalidate)
			}
		}
		# cobblestone plus (top and bottom)
		.for Y in [-1,1] {
			execute unless block ~ ~(Y) ~ $:cobblestone run (invalidate)
			.for V in [-1,1] {
				execute unless block ~(V) ~(Y) ~ $:cobblestone run (invalidate)
				execute unless block ~ ~(Y) ~(V) $:cobblestone run (invalidate)
			}
		}
		# 4 cobblestone corners
		.for X in [-1,1] {
			.for Z in [-1,1] {
				execute unless block ~(X) ~ ~(Z) $:cobblestone run (invalidate)
			}
		}
		# 4 air sides
		.for V in [-1,1] {
			execute unless block ~(V) ~ ~ #~:air run (invalidate)
			execute unless block ~ ~ ~(V) #~:air run (invalidate)
		}
		# 4 air corners
		.for X in [-1,1] {
			.for Z in [-1,1] {
				execute unless block ~(X) ~1 ~(Z) #~:air run (invalidate)
			}
		}
	}
	function start {
		title @a actionbar {"text":"Active!","color":"yellow"}
		bossbar add ~:bossbar {"text": "Nether Reactor"}
		bossbar set ~:bossbar color blue
		bossbar set ~:bossbar max 920
		bossbar set ~:bossbar value 0
		tag @s add Active
		# set red
		data modify entity @s Color set value 14
		.score IsInfiniteNight = 1
		.score @s.Reaction = 0
		.call spire
	}
	function reaction {
		.score @s.Reaction ++
		# update bossbar score
		execute store result bossbar ~:bossbar value run .score @s.Reaction get
		# within the main room
		execute positioned ~-7.5 ~-1 ~-7.5 {
			# update bossbar player list
			bossbar set ~:bossbar players @a[dx=14,dy=3,dz=14]
			# hostile pigmen
			execute as @e[type=$:zombified_piglin,dx=14,dy=3,dz=14] at @s run .call anger
		}

		# Reaction steps

		# glowing obsidian replacing cobblestone
		.if @s.Reaction == 40 run .lambda {
			fill ~-1 ~-1 ~ ~1 ~-1 ~ $:crying_obsidian
			setblock ~ ~-1 ~-1 $:crying_obsidian
			setblock ~ ~-1 ~1 $:crying_obsidian
		}
		.if @s.Reaction == 60 run .lambda {
			.for X in [-1,1] {
				.for Z in [-1,1] {
					setblock ~(X) ~ ~(Z) $:crying_obsidian
				}
			}
		}
		.if @s.Reaction == 80 run .lambda {
			fill ~-1 ~1 ~ ~1 ~1 ~ $:crying_obsidian
			setblock ~ ~1 ~-1 $:crying_obsidian
			setblock ~ ~1 ~1 $:crying_obsidian
		}
		# gold is replaced
		.if @s.Reaction == 140 run .lambda {
			.for X in [-1,1] {
				.for Z in [-1,1] {
					setblock ~(X) ~-1 ~(Z) $:crying_obsidian
				}
			}
		}
		# item and mob spawns
		.if @s.Reaction == 200 run .lambda {
			bossbar set ~:bossbar color red
			.call reactor/spawns 15 15 2
		}
		.if @s.Reaction == 260 run .lambda run .call reactor/spawns 15 15 2
		.if @s.Reaction == 400 run .lambda run .call reactor/spawns 15 15 2
		.if @s.Reaction == 440 run .lambda run .call reactor/spawns 0 35 1
		.if @s.Reaction == 500 run .lambda run .call reactor/spawns 0 40 1
		.if @s.Reaction == 600 run .lambda run .call reactor/spawns 0 32 0
		.if @s.Reaction == 680 run .lambda run .call reactor/spawns 0 20 0
		.if @s.Reaction == 720 run .lambda run .call reactor/spawns 0 24 0
		.if @s.Reaction == 760 run .lambda run .call reactor/spawns 0 36 0
		.if @s.Reaction == 800 run .lambda run .call reactor/spawns 0 20 0
		# burning out of obsidian
		.if @s.Reaction == 860 run .lambda {
			bossbar set ~:bossbar color purple
			fill ~-1 ~1 ~-1 ~1 ~1 ~1 $:obsidian
		}
		.if @s.Reaction == 880 run .lambda {
			fill ~-1 ~ ~-1 ~1 ~ ~1 $:obsidian
			setblock ~~~ $:air
		}
		.if @s.Reaction == 900 run fill ~-1 ~-1 ~-1 ~1 ~-1 ~1 $:obsidian
		# end of reaction
		.if @s.Reaction >= 920 run .call core/end
	}
	function end {
		# update to dead
		tag @s remove Active
		tag @s add Dead
		# set black
		data modify entity @s Color set value 7
		# remove bossbar
		execute unless entity @reactors[tag=Active] run bossbar remove ~:bossbar
		# remove Infinite night
		.score IsInfiniteNight = 0
		# structure changes
		fill ~-1 ~-1 ~-1 ~1 ~1 ~1 $:obsidian
		setblock ~~~ air
		.call decay_spire
	}
}
loot core {
	"type": "command",
	"pools": [{
		"rolls": 1,
		"entries": [{
			"type": "minecraft:item",
			"name": "minecraft:light_blue_shulker_box",
			"functions": [
				{
					"function": "minecraft:set_nbt",
					"tag": "{\"core\":\"nether\", \"BlockEntityTag\":{\"Items\":[{\"Slot\":0,\"id\":\"minecraft:diamond\",\"Count\":1,\"tag\":{\"core\":\"nether\"}}]}}"
				},
				{
					"function": "minecraft:set_name",
					"name": {
						"text": "Nether Reactor Core",
						"color": "yellow"
					}
				}
			],
			"weight": 1
		}]
	}]
}

# still as @reactors
in reactor {
	function spawns takes RNG_Min RNG_Max MobLimit {
		.do rng
		.score ItemCount = RNG
		execute positioned ~ ~-1 ~ run .call reactor/spawn_items
		.score ItemCount reset
		# locating pigmen
		.if MobLimit > 0 run .call reactor/spawn_mobs
		.score MobLimit reset
	}
	function spawn_items {
		.if ItemCount > 0 run .lambda {
			.call reactor/random_spot
			.define @spot @nearest[type=$:area_effect_cloud,tag=RandomSpot]
			execute at @spot run loot spawn ~~~ loot ~:rewards
			kill @spot
			.score ItemCount --
			.if ItemCount > 0 run .recurse
		}
	}
	function spawn_mobs {
		.score MobCount = 0
		execute positioned ~-7.5 ~-1 ~-7.5 {
			execute as @e[type=$:zombified_piglin,dx=14,dy=3,dz=14] run .score MobCount ++
		}
		.if MobCount < 3 run .lambda {
			.call reactor/spawn_mob
			.score MobCount ++
			.score MobLimit --
			.if MobCount < 3 run .if MobLimit > 0 run .recurse
		}
		.score MobCount reset
	}
	function spawn_mob {
		.call reactor/random_spot
		.define @spot @nearest[type=$:area_effect_cloud,tag=RandomSpot]
		execute at @spot run summon $:zombified_piglin ~~~
		kill @spot
	}
	function random_spot {
		# distance of 3 - 7 blocks, 0.5 steps
		.call rng 6 14
		.score Distance = RNG
		.score Distance ++
		# angle up to 360 degrees, 5 deg steps
		.call rng 1 72
		.score Angle = RNG

		execute positioned ~ ~-1 ~ rotated 0 0 run .lambda {
			.score Angle --
			.if Angle == 0 run .lambda {
				.score Distance --
				.if Distance == 0 run .lambda {
					summon $:area_effect_cloud ~~~ {Duration:2}
					tag @nearest[type=$:area_effect_cloud] add RandomSpot
				}
				.if Distance > 0 {
					execute positioned ^ ^ ^0.5 run .recurse
				}
			}
			.if Angle > 0 {
				execute rotated ~5 0 run .recurse
			}
		}

		.score Distance reset
		.score Angle reset
	}
	
}
loot rewards {
	"type": "command",
	"pools": [{
		"rolls": 1,
		"entries": [
			{"type": "minecraft:item", "name": "minecraft:red_mushroom", "weight": 1},
			{"type": "minecraft:item", "name": "minecraft:brown_mushroom", "weight": 1},
			{"type": "minecraft:item", "name": "minecraft:cactus", "weight": 1},
			{
				"type": "minecraft:item", "weight": 1,
				"name": "minecraft:quartz",
				"functions": [
					{"function": "minecraft:set_count", "count": 4}
				]
			},
			{"type": "minecraft:item", "name": "minecraft:sugar_cane", "weight": 1},
			{
				"type": "minecraft:item", "weight": 1,
				"name": "minecraft:glowstone_dust",
				"functions": [
					{"function": "minecraft:set_count", "count": 3}
				]
			},
			{"type": "minecraft:item", "name": "minecraft:pumpkin_seeds", "weight": 1},
			{"type": "minecraft:item", "name": "minecraft:melon_seeds", "weight": 1}
		]
	}]
}

# as @p
in player {
	function check_pickaxe {
		.for Pickaxe in [$:iron_pickaxe,$:diamond_pickaxe,$:netherite_pickaxe] {
			execute if entity @s[nbt={SelectedItem:{id:"(Pickaxe)"}}] {
				tag @s add HasPickaxe
			}
		}
	}
	function start_search {
		tag @s add SearchingForCores
		.score @s.SearchTime = 5
	}
	function searching {
		.for Block in (BlockNames) {
			.define Item (SourceItem[(Block)])
			.define ID (BlockID[(Block)])
			.define TargetScore (PlaceScore[(Block)])
			execute if entity @s[scores={HeldBlockID=(ID)}] at @s {
				.if @s.(TargetScore) > 0 run .call player/place/(Block)
			}
		}
		.score @s.SearchTime --
		.if @s.SearchTime == 0 run tag @s remove SearchingForCores
	}
	in place {
		for Block in (BlockNames) {
			function (Block) {
				.score @s.Raytrace = 5000
				execute anchored eyes run .lambda {
					.score @s.Raytrace --
					execute unless block ~~~ (SourceItem[(Block)]) {
						.if @s.Raytrace > 0 {
							execute positioned ^ ^ ^0.01 run .recurse
						}
					}
					execute if block ~~~ (SourceItem[(Block)]) run .call place/(Block)
				}
			}
		}
	}
	function look {
		# at position of target entity

		# count player as near a core
		.score @s.IsInRange = 1

		# looking from target block to self, step forward
		execute facing entity @s eyes positioned ^ ^ ^1 {
			# Looking with player angle, step back
			execute rotated as @s positioned ^ ^ ^1 {
				# If we are close to looking at the block center
				.define @target @e[type=$:armor_stand,tag=Target,distance=..0.5]
				execute if entity @target run .lambda {
					.call player/trace
					# If definitely looking
					.if Success == 1 {
						# If not mining, then send to allow right click
						.if @s.BlockMine == 0 run .score @target.Looking ++

						# Creative Mode insta-mine
						.unless @s.BlockMine == 0 run execute if entity @s[gamemode=creative] {
							execute at @target run setblock ~~~ air
							# Reset mining since a block has been mined
							.score @s.BlockMine = 0
						}

						# Attack boost to allow punching to break
						execute unless entity @s[nbt={ActiveEffects:[{Id:5b}]}] run effect give @s $:strength 1 0 true
					}
					# Reset BlockMine when not looking
					.if Success == 0 run .score @s.BlockMine = 0
				}
				# Reset BlockMine when not even close to looking
				execute unless entity @target run .score @s.BlockMine = 0
			}
		}
	}
	function trace {
		.score Success = 0
		.score @s.Raytrace = 5000
		execute at @s anchored eyes run .lambda {
			.score @s.Raytrace --
			execute unless block ~~~ (SourceBlock[core]) {
				.if @s.Raytrace > 0 {
					execute positioned ^ ^ ^0.01 run .recurse
				}
			}
			execute if block ~~~ (SourceBlock[core]) {
				.score Success = 1
			}
		}
	}
}

# as pigman in main spire room during reaction
function anger {
	execute unless data entity @s AngryAt {
		execute if entity @p[distance=..4] {
			data modify entity @s AngerTime set value 50
			data modify entity @s AngryAt set from entity @p[distance=..4] UUID
		}
	}
}


function craft {
	.json NetherReactorCoreItem {
		"Item": {
			"id": "minecraft:light_blue_shulker_box",
			"Count": 1,
			"tag": {
				"core": "nether",
				"display": {"Name": "{\"text\":\"Nether Reactor Core\",\"color\":\"yellow\"}"},
				"BlockEntityTag": {
					"Items": [{
						"Slot": 0,
						"id": "minecraft:diamond",
						"Count": 1,
						"tag": {
							"core": "nether"
						}
					}]
				}
			}
		}
	}
	kill @irons[limit=1,sort=nearest]
	kill @s
	summon $:item ~~~ (NetherReactorCoreItem)
	particle $:composter ~~~ 0.25 0.5 0.25 0.5 50 normal
}

function place {
	setblock ~~~ $:air
	summon $:shulker ~~~ {"NoAI":true,"Color":3b}
	execute as @nearest[type=$:shulker] run .call core/init
}

function empty_spawner {
	data modify block ~~~ RequiredPlayerRange set value 0
	data modify block ~~~ SpawnData set value {}
	data modify block ~~~ SpawnPotentials set value []
}

in place {
	for Block in (BlockNames) {
		define ID (BlockID[(Block)])
		define Item (SourceItem[(Block)])
		function (Block) {
			setblock ~~~ (SourceBlock[(Block)])
			execute if block ~~~ $:spawner run .call empty_spawner
			execute align xyz {
				summon $:armor_stand ~0.5 ~0.5 ~0.5 {Marker:1,Invisible:1,NoGravity:1,ArmorItems:[{},{},{},{id:"(Item)",Count:1b,tag:{CustomModelData:(ID)}}],Tags:["NetherReactorCustomBlock"]}
			}
		}
	}

}

in give {
	json CoreText {
		"text": "Nether Reactor Core",
		"italic": false
	}
	json GlowObsText {
		"text": "Glowing Obsidian",
		"italic": false
	}
	for Core in (Cores) {
		function (Core) {
			give @p $:diamond_ore{CustomModelData:(BlockID[(Core)]),display:{Name:(string[CoreText])}}
		}
	}
	function glowing_obsidian {
		give @p $:crying_obsidian{CustomModelData:(BlockID[glowing_obsidian]),display:{Name:(string[GlowObsText])}}
	}
}

structure nether_spire
function spire {
	setblock ~ ~-3 ~ minecraft:structure_block{mode:"LOAD",powered:0b,name:"~:nether_spire",posX:-8,posZ:-8}
	setblock ~ ~-2 ~ $:redstone_block
}

function decay_spire {
	.define mark loot spawn (here) loot ~:decay_rng
	# .define mark summon $:armor_stand (here) {NoGravity:true}

	# outer wall
	.range Height -1 5
	.for Y in (Height) {
		.define here ~-8 ~(Y) ~-8
		(mark)
	}
	.range Width -7 8
	.for I in (Width) {
		.eval H (I)/2 + 9
		.eval H math.ceil((H))
		.range Height -1 (H)
		.for Y in (Height) {
			.define here ~(I) ~(Y) ~-8
			(mark)
			.define here ~-8 ~(Y) ~(I)
			(mark)
		}
	}
	.range Width -7 7
	.for I in (Width) {
		.eval H (I)/2 + 17
		.eval H math.floor((H))
		.range Height -1 (H)
		.for Y in (Height) {
			.define here ~(I) ~(Y) ~8
			(mark)
			.define here ~8 ~(Y) ~(I)
			(mark)
		}
	}
	.range Height -1 20
	.for Y in (Height) {
		.define here ~8 ~(Y) ~8
		(mark)
	}

	# middle wall
	.range Height 5 22
	.for Y in (Height) {
		.define here ~-5 ~(Y) ~-5
		(mark)
	}
	.range Width -4 5
	.for I in (Width) {
		.eval H 20 - (I)/2
		.eval H math.ceil((H))
		.range Height 5 (H)
		.for Y in (Height) {
			.define here ~(I) ~(Y) ~-5
			(mark)
			.define here ~-5 ~(Y) ~(I)
			(mark)
		}
	}
	.range Width -4 0
	.for I in (Width) {
		.eval H 16 - (I)/2
		.eval H math.floor((H))
		.range Height 5 (H)
		.for Y in (Height) {
			.define here ~(I) ~(Y) ~5
			(mark)
			.define here ~5 ~(Y) ~(I)
			(mark)
		}
	}
	.range Width 1 4
	.for I in (Width) {
		.eval H 15 + (I)/2
		.eval H math.ceil((H))
		.range Height 5 (H)
		.for Y in (Height) {
			.define here ~(I) ~(Y) ~5
			(mark)
			.define here ~5 ~(Y) ~(I)
			(mark)
		}
	}
	.range Height 5 18
	.for Y in (Height) {
		.define here ~5 ~(Y) ~5
		(mark)
	}

	# inner wall
	.range Height 11 25
	.for Y in (Height) {
		.define here ~-3 ~(Y) ~-3
		(mark)
	}
	.range Width -2 3
	.for I in (Width) {
		.eval H (I)/2 + 27
		.eval H math.floor((H))
		.range Height 11 (H)
		.for Y in (Height) {
			.define here ~(I) ~(Y) ~-3
			(mark)
			.define here ~-3 ~(Y) ~(I)
			(mark)
		}
	}
	.range Width -2 2
	.for I in (Width) {
		.eval H (I)/2 + 29
		.eval H math.ceil((H))
		.range Height 11 (H)
		.for Y in (Height) {
			.define here ~(I) ~(Y) ~3
			(mark)
			.define here ~3 ~(Y) ~(I)
			(mark)
		}
	}
	.range Height 11 30
	.for Y in (Height) {
		.define here ~3 ~(Y) ~3
		(mark)
	}

	# decay at marked areas
	execute as @decayer at @s run .lambda {
		setblock ~~~ $:air replace
		kill @s
	}
}
loot decay_rng {
	"type": "command",
	"pools": [{
		"conditions": [{
			"condition": "minecraft:random_chance",
			"chance": 0.25
		}],
		"rolls": 1,
		"entries": [{
			"type": "minecraft:item",
			"name": "minecraft:netherrack",
			"functions": [{
				"function": "minecraft:set_nbt",
				"tag": "{\"decayer\":true}"
			}],
			"weight": 1
		}]
	}]
}

function infinite_night {
	.set InfiniteNightTimer run time query daytime
	.if InfiniteNightTimer >= 18000 run .if InfiniteNightTimer < 18150 run time set midnight
	.if InfiniteNightTimer < 18000 run time add 100
	.if InfiniteNightTimer >= 18150 run time add 100
}

function rng100 {
	loot spawn ~ 999 ~ loot ~:rng100
	.define @rng @item[distance=..1,nbt={Item:{tag:{rng:1b}}}]
	.score RNG = 0
	execute positioned ~ 999 ~ as @rng run .lambda {
		.set Temp run data get entity @s Item.Count
		.score RNG += Temp
		kill @s
	}
	.score Temp reset
}
loot rng100 {
	"type": "command",
	"pools": [{
		"rolls": 1,
		"entries": [{
			"type": "minecraft:item",
			"name": "minecraft:dirt",
			"functions": [
				{
					"function": "minecraft:set_count",
					"count": {
						"type": "uniform",
						"min": 0, "max": 100
					}
				},
				{
					"function": "minecraft:set_nbt",
					"tag": "{\"rng\":true}"
				}
			]
		}]
	}]
}
function rng takes RNG_Min RNG_Max {
	.call rng100
	.score RNG_Diff = RNG_Max
	.score RNG_Diff -= RNG_Min
	.score RNG_Scale = 100
	.score RNG_Scale /= RNG_Diff
	.score RNG /= RNG_Scale
	.score RNG += RNG_Min
	.score RNG < RNG_Max
	.score RNG_Diff reset
	.score RNG_Scale reset
}