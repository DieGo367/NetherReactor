pack Adds the Nether Reactor from early versions of Minecraft: Pocket Edition
icon nether_reactor

namespace minecraft
tag functions load [nether_reactor:init]
tag functions tick [nether_reactor:tick]


namespace nether_reactor
nameglobals NetherReactorVar

tag blocks air [minecraft:air,minecraft:cave_air]

define @nearest @e[limit=1,sort=nearest]
define @item @e[type=$:item]
define @decayer @item[nbt={Item:{tag:{decayer:1b}}}]
define @diamonds @item[nbt={Item:{id:"minecraft:diamond",Count:3b}}]
define @irons @item[nbt={Item:{id:"minecraft:iron_ingot",Count:6b}}]
define @blocks @e[type=$:armor_stand,tag=NetherReactorCustomBlock]
define @clickers @e[type=$:villager,tag=NetherReactorRightClicker]

define setWarnMsg data modify storage ~:warn msg set value
enum BAR CHAT TITLE

# Custom Block Data
list BlockNames core core_active core_dead glowing_obsidian
list BlockIDs 1 2 3 4
list SourceBlocks $:spawner $:spawner $:spawner $:crying_obsidian
list SourceItems $:diamond_ore $:diamond_ore $:diamond_ore $:crying_obsidian
list PlaceScores PlacedDiamondOre PlacedDiamondOre PlacedDiamondOre PlacedCryingObs
list LootTables ~:block/core ~:block/core ~:block/core ~:block/glowing_obsidian
# Custom Block Table Maps
map BlockID maps (BlockNames) to (BlockIDs)
map SourceBlock maps (BlockNames) to (SourceBlocks)
map SourceItem maps (BlockNames) to (SourceItems)
map LootTable maps (BlockNames) to (LootTables)
map PlaceScore maps (BlockNames) to (PlaceScores)
# Custom Block Text
define Text[core] Nether Reactor Core
define Text[core_active] (Text[core])
define Text[core_dead] (Text[core])
define Text[glowing_obsidian] Glowing Obsidian
# Custom Block Hooks
list HasUse core
list UseHooks ~:core/activation_check
list HasBreak core core_active
list BreakHooks ~:core/break ~:core/break
# Hook table maps
map UseHook maps (HasUse) to (UseHooks)
map BreakHook maps (HasBreak) to (BreakHooks)

function init {
	.scoredef
	.score WarnLoc = (BAR)
	# core 
	.scoredef Y
	.scoredef Reaction
	.scoredef Looking
	.scoredef LookedAt
	.scoredef Used
	# player
		# block placement
		.scoredef SearchTime
		.scoredef Raytrace
		.scoredef HeldBlockID
		.scoredef PlacedDiamondOre minecraft.used:minecraft.diamond_ore
		.scoredef PlacedCryingObs minecraft.used:minecraft.crying_obsidian
		# block use
		.scoredef IsInRange
		.scoredef WasInRange
		.scoredef HasLooked
		.scoredef Sneaking minecraft.custom:minecraft.sneak_time
		.scoredef BlockMine minecraft.custom:minecraft.damage_dealt
		.scoredef BlockUse minecraft.custom:minecraft.talked_to_villager
}

function tick {
	# crafting recipe
	execute as @diamonds at @s {
		execute if block ~ ~-1 ~ minecraft:crafting_table {
			execute if entity @irons[distance=..1] run .call craft
		}
	}

	# block mask deletion
	execute as @blocks at @s {
		execute if block ~~~ #~:air run .call block/break
	}

	# right clicker logic
	execute as @clickers at @s run .lambda {
		# kill clickers that are missing a block and have not just spawned
		execute unless entity @s[tag=JustSpawned] if block ~ ~1.5 ~ #~:air run tp @s ~ ~-1000 ~
		# move clickers down to their block after having spawned for a tick
		execute if entity @s[tag=JustSpawned] run tp @s ~ ~-1000 ~
		tag @s remove JustSpawned
	}

	# block use detection
	.call block/use_check
	
	# block placement detection
	.call block/place_check
	
	# core tick update
	execute as @blocks[tag=ActiveCore] at @s positioned ~ ~-0.5 ~ run .call core/reaction
	
	# infinite night
	.if IsInfiniteNight == 1 run .call infinite_night
}

in block {
	# general
	function use_check {
		.score @blocks.Looking = 0
		.score @a.IsInRange = 0
		.score @a.HasLooked = 0
		
		# ask each nearby player to tally if they can see and right click the block
		.for Block in (HasUse) {
			execute as @blocks[nbt={ArmorItems:[{tag:{CustomModelData:(BlockID[(Block)])}}]}] at @s run .call block/player_poll
		}
		execute as @blocks[scores={Looking=0}] at @s run {
			# if a block is not looked at, disable clickers
			.call block/disable_click
			.score @s.LookedAt = 0
		}
		execute as @blocks[scores={Looking=1..}] at @s run {
			# when a block starts to be looked at, enable clickers
			.unless @s.LookedAt == 1 run .call block/enable_click
			.score @s.LookedAt = 1
		}
		execute as @blocks[scores={Used=1..}] at @s run {
			.for Block in (HasUse) {
				execute if entity @s[nbt={ArmorItems:[{tag:{CustomModelData:(BlockID[(Block)])}}]}] run .call (UseHook[(Block)])
			}
			.score @s.Used = 0
		}
		execute as @a {
			# if a player walks into range of a core, reset BlockMine to enable right click detection
			.if @s.IsInRange == 1 run .if @s.WasInRange == 0 {
				.score @s.BlockMine = 0
			}
			.if @s.HasLooked == 0 run .score @s.BlockMine = 0
			.score @s.WasInRange = @s.IsInRange
			.score @s.Sneaking = 0
		}
	}
	function place_check {
		# check as players identified to be holding a custom block
		execute as @a run .unless @s.HeldBlockID == 0 run .call player/start_place_checks
		execute as @a[tag=Checking] at @s run .call player/place_check
		.for Score in (set[PlaceScores]) {
			.score @a.(Score) = 0
		}
		.score @a.HeldBlockID = 0
		.define OffHand Inventory:[{Slot:-106b,(REST)}]
		.define MainHand SelectedItem:{(REST)}
		.for Hand in [OffHand,MainHand] {
			.for Block in (BlockNames) {
				.define ID (BlockID[(Block)])
				.define Item (SourceItem[(Block)])
				.define REST id:"(Item)",tag:{CustomModelData:(ID)}
				execute as @a[nbt={((Hand))}] {
					.score @s.HeldBlockID = (ID)
				}
			}
		}
		.for Item in (set[SourceItems]) {
			.define REST id:"(Item)"
			execute as @a[nbt={(MainHand)}] run .lambda {
				.set Temp run data get entity @s SelectedItem.tag.CustomModelData
				.if Temp == 0 run .score @s.HeldBlockID = 0
			}
		}
	}
	# as @blocks
	function player_poll {
		tag @s add Target
		execute as @a[distance=..4,scores={Sneaking=0}] run .call player/look
		tag @s remove Target
	}
	in place {
		for Block in (BlockNames) {
			define ID (BlockID[(Block)])
			define Item (SourceItem[(Block)])
			function (Block) {
				setblock ~~~ (SourceBlock[(Block)])
				execute if block ~~~ $:spawner run .call block/empty_spawner
				execute align xyz {
					summon $:armor_stand ~0.5 ~0.5 ~0.5 {Marker:1,Invisible:1,NoGravity:1,ArmorItems:[{},{},{},{id:"(Item)",Count:1b,tag:{CustomModelData:(ID)}}],Tags:["NetherReactorCustomBlock"]}
				}
			}
		}
	}
	function break {
		.call block/disable_click

		.define @xp @e[type=$:experience_orb,distance=..0.1]
		.define @drop @item[distance=..0.5]

		# if loot or xp is dropped, then the player is in survival. kill the drops
		.score Dropped = 0
		execute if entity @drop run .score Dropped = 1
		kill @drop
		execute if entity @xp run .score Dropped = 1
		kill @xp
		# if so, summon the appropriate loot for the custom block
		.if Dropped == 1 run .lambda {
			.for Block in (BlockNames) {
				.define ID (BlockID[(Block)])
				.define Item (SourceItem[(Block)])
				.define LootTable (LootTable[(Block)])
				execute if entity @s[nbt={ArmorItems:[{id:"(Item)",tag:{CustomModelData:(ID)}}]}] run loot spawn ~~~ loot (LootTable)
			}
		}

		# call custom block break hook
		.for Block in (HasBreak) {
			.define ID (BlockID[(Block)])
			.define Item (SourceItem[(Block)])
			.define Callback (BreakHook[(Block)])
			execute if entity @s[nbt={ArmorItems:[{id:"(Item)",tag:{CustomModelData:(ID)}}]}] run .call (Callback)
		}

		kill @s
	}
	define VillagerOffset -1.449
	function enable_click {
		.json VillagerData {
			"NoAI": true,
			"Silent": true,
			"Tags": ["NetherReactorRightClicker", "JustSpawned"],
			"ActiveEffects": [
				{"Id": 10, "Amplifier": 3, "Duration": 2147483647, "ShowParticles": false},
				{"Id": 14, "Amplifier": 0, "Duration": 2147483647, "ShowParticles": false}
			]
		}
		execute positioned ~ ~(VillagerOffset) ~ {
			.define mag 0.202
			.list pos -(mag) (mag)
			.for X in (pos) {
				.for Z in (pos) {
					summon $:villager ~(X) ~1000 ~(Z) (VillagerData)
				}
			}
		}
	}
	function disable_click {
		execute positioned ~ ~(VillagerOffset) ~ run tp @clickers[distance=..0.5] ~ ~-1000 ~
	}
	function empty_spawner {
		data modify block ~~~ RequiredPlayerRange set value 0
		data modify block ~~~ SpawnData set value {}
		data modify block ~~~ SpawnPotentials set value []
	}
	json ItemText {
		"text": "(Text)",
		"italic": false
	}
	for Block in [core,glowing_obsidian] {
		define ID (BlockID[(Block)])
		define Item (SourceItem[(Block)])
		define Text (Text[(Block)])
		json TagData {
			"CustomModelData": (ID),
			"display": {
				"Name": (string[ItemText])
			}
		}
		loot (Block) {
			"type": "command",
			"pools": [{
				"rolls": 1,
				"entries": [{
					"type": "$:item", "name": "(Item)",
					"functions": [
						{"function": "$:set_nbt", "tag": (string[TagData])}
					]
				}]
			}]
		}
	}
}

# as @blocks
in core {
	function break {
		bossbar set ~:bossbar players
	}
	function activation_check {
		.set @s.Y run data get entity @s Pos[1]
		.if @s.Y > 7 run .if @s.Y < 223 run .lambda {
			.call core/structure_check
			execute if entity @s[tag=IsValid] run .call core/start
			execute unless entity @s[tag=IsValid] run (setWarnMsg) "Not the correct pattern!"
		}
		.unless @s.Y > 7 run (setWarnMsg) "The nether reactor needs to be built higher up."
		.unless @s.Y < 223 run (setWarnMsg) "The nether reactor needs to be built lower down."
		
		execute if data storage ~:warn msg run .lambda {
			.if WarnLoc == (BAR) run title @p actionbar {"text":"","extra":[{"storage":"~:warn","nbt":"msg"}]}
			.if WarnLoc == (TITLE) run title @p title {"text":"","extra":[{"storage":"~:warn","nbt":"msg"}]}
			.if WarnLoc == (CHAT) run tellraw @p {"text":"","extra":[{"storage":"~:warn","nbt":"msg"}]}
			data remove storage ~:warn msg
		}
	}
	function structure_check {
		tag @s add IsValid
		.define invalidate tag @s remove IsValid

		# 4 gold corners
		.for X in [-1,1] {
			.for Z in [-1,1] {
				execute unless block ~(X) ~-1 ~(Z) $:gold_block run (invalidate)
			}
		}
		# cobblestone plus (top and bottom)
		.for Y in [-1,1] {
			execute unless block ~ ~(Y) ~ $:cobblestone run (invalidate)
			.for V in [-1,1] {
				execute unless block ~(V) ~(Y) ~ $:cobblestone run (invalidate)
				execute unless block ~ ~(Y) ~(V) $:cobblestone run (invalidate)
			}
		}
		# 4 cobblestone corners
		.for X in [-1,1] {
			.for Z in [-1,1] {
				execute unless block ~(X) ~ ~(Z) $:cobblestone run (invalidate)
			}
		}
		# 4 air sides
		.for V in [-1,1] {
			execute unless block ~(V) ~ ~ #~:air run (invalidate)
			execute unless block ~ ~ ~(V) #~:air run (invalidate)
		}
		# 4 air corners
		.for X in [-1,1] {
			.for Z in [-1,1] {
				execute unless block ~(X) ~1 ~(Z) #~:air run (invalidate)
			}
		}
	}
	function start {
		title @a actionbar {"text":"Active!","color":"yellow"}
		bossbar add ~:bossbar {"text": "Nether Reactor"}
		bossbar set ~:bossbar color blue
		bossbar set ~:bossbar max 920
		bossbar set ~:bossbar value 0
		tag @s add ActiveCore
		# set red
		data modify entity @s ArmorItems[3].tag.CustomModelData set value (BlockID[core_active])
		.score IsInfiniteNight = 1
		.score @s.Reaction = 0
		.call spire
	}
	function reaction {
		.score @s.Reaction ++
		# update bossbar score
		execute store result bossbar ~:bossbar value run .score @s.Reaction get
		# within the main room
		execute positioned ~-7.5 ~-1 ~-7.5 {
			# update bossbar player list
			bossbar set ~:bossbar players @a[dx=14,dy=3,dz=14]
			# hostile pigmen
			execute as @e[type=$:zombified_piglin,dx=14,dy=3,dz=14] at @s run .call anger
		}

		# Reaction steps

		# glowing obsidian replacing cobblestone
		.if @s.Reaction == 40 run .lambda {
			.for X in [-1,0,1] run execute positioned ~(X) ~-1 ~ run .call block/place/glowing_obsidian 
			.for Z in [-1,1] run execute positioned ~ ~-1 ~(Z) run .call block/place/glowing_obsidian 
		}
		.if @s.Reaction == 60 run .lambda {
			.for X in [-1,1] {
				.for Z in [-1,1] {
					execute positioned ~(X) ~ ~(Z) run .call block/place/glowing_obsidian
				}
			}
		}
		.if @s.Reaction == 80 run .lambda {
			.for X in [-1,0,1] run execute positioned ~(X) ~1 ~ run .call block/place/glowing_obsidian 
			.for Z in [-1,1] run execute positioned ~ ~1 ~(Z) run .call block/place/glowing_obsidian 
		}
		# gold is replaced
		.if @s.Reaction == 140 run .lambda {
			.for X in [-1,1] {
				.for Z in [-1,1] {
					execute positioned ~(X) ~-1 ~(Z) run .call block/place/glowing_obsidian
				}
			}
		}
		# item and mob spawns
		.if @s.Reaction == 200 run .lambda {
			bossbar set ~:bossbar color red
			.call core/spawns 15 15 2
		}
		.if @s.Reaction == 260 run .lambda run .call core/spawns 15 15 2
		.if @s.Reaction == 400 run .lambda run .call core/spawns 15 15 2
		.if @s.Reaction == 440 run .lambda run .call core/spawns 0 35 1
		.if @s.Reaction == 500 run .lambda run .call core/spawns 0 40 1
		.if @s.Reaction == 600 run .lambda run .call core/spawns 0 32 0
		.if @s.Reaction == 680 run .lambda run .call core/spawns 0 20 0
		.if @s.Reaction == 720 run .lambda run .call core/spawns 0 24 0
		.if @s.Reaction == 760 run .lambda run .call core/spawns 0 36 0
		.if @s.Reaction == 800 run .lambda run .call core/spawns 0 20 0
		# burning out of obsidian
		.define clear run execute positioned ~(X) ~(Y) ~(Z) run kill @blocks[distance=..0.1]
		.if @s.Reaction == 860 run .lambda {
			bossbar set ~:bossbar color purple
			.define Y 1.5
			.for X in [-1,0,1] run .for Z in [-1,0,1] (clear)
			fill ~-1 ~1 ~-1 ~1 ~1 ~1 $:obsidian
		}
		.if @s.Reaction == 880 run .lambda {
			.define Y 0.5
			.for X in [-1,0,1] run .for Z in [-1,1] (clear)
			.for X in [0] run .for Z in [-1,1] (clear)
			fill ~1 ~ ~1 ~1 ~ ~-1 $:obsidian
			fill ~-1 ~ ~1 ~-1 ~ ~-1 $:obsidian
			setblock ~ ~ ~1 $:obsidian
			setblock ~ ~ ~-1 $:obsidian
		}
		.if @s.Reaction == 900 run .lambda {
			.define Y -0.5
			.for X in [-1,0,1] run .for Z in [-1,0,1] (clear)
			fill ~-1 ~-1 ~-1 ~1 ~-1 ~1 $:obsidian
		}
		# end of reaction
		.if @s.Reaction >= 920 run .call core/end
	}
	function end {
		# update to dead
		tag @s remove ActiveCore
		# set black
		data modify entity @s ArmorItems[3].tag.CustomModelData set value (BlockID[core_dead])
		# remove bossbar
		bossbar set ~:bossbar players
		execute unless entity @blocks[tag=ActiveCore] run bossbar remove ~:bossbar
		# remove Infinite night
		.score IsInfiniteNight = 0
		# structure changes
		fill ~-1 ~1 ~-1 ~1 ~1 ~1 $:obsidian
		fill ~1 ~ ~1 ~1 ~ ~-1 $:obsidian
		fill ~-1 ~ ~1 ~-1 ~ ~-1 $:obsidian
		setblock ~ ~ ~1 $:obsidian
		setblock ~ ~ ~-1 $:obsidian
		fill ~-1 ~-1 ~-1 ~1 ~-1 ~1 $:obsidian
		.call decay_spire
	}
	# Reaction functions
	function spawns takes RNG_Min RNG_Max MobLimit {
		.do rng
		.score ItemCount = RNG
		execute positioned ~ ~-1 ~ run .call core/spawn_items
		.score ItemCount reset
		# locating pigmen
		.if MobLimit > 0 run .call core/spawn_mobs
		.score MobLimit reset
	}
	function spawn_items {
		.if ItemCount > 0 run .lambda {
			.call core/random_spot
			.define @spot @nearest[type=$:area_effect_cloud,tag=RandomSpot]
			execute at @spot run loot spawn ~~~ loot ~:rewards
			kill @spot
			.score ItemCount --
			.if ItemCount > 0 run .recurse
		}
	}
	function spawn_mobs {
		.score MobCount = 0
		execute positioned ~-7.5 ~-1 ~-7.5 {
			execute as @e[type=$:zombified_piglin,dx=14,dy=3,dz=14] run .score MobCount ++
		}
		.if MobCount < 3 run .lambda {
			.call core/spawn_mob
			.score MobCount ++
			.score MobLimit --
			.if MobCount < 3 run .if MobLimit > 0 run .recurse
		}
		.score MobCount reset
	}
	function spawn_mob {
		.call core/random_spot
		.define @spot @nearest[type=$:area_effect_cloud,tag=RandomSpot]
		execute at @spot run summon $:zombified_piglin ~~~
		kill @spot
	}
	function random_spot {
		# distance of 3 - 7 blocks, 0.5 steps
		.call rng 6 14
		.score Distance = RNG
		.score Distance ++
		# angle up to 360 degrees, 5 deg steps
		.call rng 1 72
		.score Angle = RNG

		execute positioned ~ ~-1 ~ rotated 0 0 run .lambda {
			.score Angle --
			.if Angle == 0 run .lambda {
				.score Distance --
				.if Distance == 0 run .lambda {
					summon $:area_effect_cloud ~~~ {Duration:2}
					tag @nearest[type=$:area_effect_cloud] add RandomSpot
				}
				.if Distance > 0 {
					execute positioned ^ ^ ^0.5 run .recurse
				}
			}
			.if Angle > 0 {
				execute rotated ~5 0 run .recurse
			}
		}

		.score Distance reset
		.score Angle reset
	}
	
}
loot rewards {
	"type": "command",
	"pools": [{
		"rolls": 1,
		"entries": [
			{"type": "minecraft:item", "name": "minecraft:red_mushroom", "weight": 1},
			{"type": "minecraft:item", "name": "minecraft:brown_mushroom", "weight": 1},
			{"type": "minecraft:item", "name": "minecraft:cactus", "weight": 1},
			{
				"type": "minecraft:item", "weight": 1,
				"name": "minecraft:quartz",
				"functions": [
					{"function": "minecraft:set_count", "count": 4}
				]
			},
			{"type": "minecraft:item", "name": "minecraft:sugar_cane", "weight": 1},
			{
				"type": "minecraft:item", "weight": 1,
				"name": "minecraft:glowstone_dust",
				"functions": [
					{"function": "minecraft:set_count", "count": 3}
				]
			},
			{"type": "minecraft:item", "name": "minecraft:pumpkin_seeds", "weight": 1},
			{"type": "minecraft:item", "name": "minecraft:melon_seeds", "weight": 1}
		]
	}]
}

# as @p
in player {
	function start_place_checks {
		tag @s add Checking
		.score @s.SearchTime = 5
	}
	function place_check {
		.for Block in (BlockNames) {
			.define Item (SourceItem[(Block)])
			.define ID (BlockID[(Block)])
			.define TargetScore (PlaceScore[(Block)])
			execute if entity @s[scores={HeldBlockID=(ID)}] at @s {
				.if @s.(TargetScore) > 0 run .call player/place/(Block)
			}
		}
		.score @s.SearchTime --
		.if @s.SearchTime == 0 run tag @s remove Checking
	}
	in place {
		for Block in (BlockNames) {
			function (Block) {
				.score @s.Raytrace = 5000
				execute anchored eyes run .lambda {
					.score @s.Raytrace --
					execute unless block ~~~ (SourceItem[(Block)]) {
						.if @s.Raytrace > 0 {
							execute positioned ^ ^ ^0.01 run .recurse
						}
					}
					execute if block ~~~ (SourceItem[(Block)]) run .call block/place/(Block)
				}
			}
		}
	}
	function look {
		# at position of target entity

		# count player as near a core
		.score @s.IsInRange = 1

		# looking from target block to self, step forward
		execute facing entity @s eyes positioned ^ ^ ^1 {
			# Looking with player angle, step back
			execute rotated as @s positioned ^ ^ ^1 {
				# If we are close to looking at the block center
				.define @target @e[type=$:armor_stand,tag=Target,distance=..0.5]
				execute if entity @target run .lambda {
					.call player/trace
					# If definitely looking
					.if Success == 1 {
						.score @s.HasLooked ++

						# claim detected right click
						.if @s.BlockUse > 0 run .score @target.Used ++
						.score @s.BlockUse = 0

						# If not mining, then send to allow right click
						.if @s.BlockMine == 0 run {
							.score @target.Looking ++
						}

						# Creative Mode insta-mine
						.unless @s.BlockMine == 0 run execute if entity @s[gamemode=creative] {
							execute at @target run setblock ~~~ air
							# Reset mining since a block has been mined
							.score @s.BlockMine = 0
						}

						# Attack boost to allow punching to break
						execute unless entity @s[nbt={ActiveEffects:[{Id:5b}]}] run effect give @s $:strength 1 0 true
					}
				}
			}
		}
	}
	function trace {
		.score Success = 0
		.score @s.Raytrace = 5000
		execute at @s anchored eyes run .lambda {
			.score @s.Raytrace --
			execute align xyz positioned ~0.5 ~0.5 ~0.5 if entity @e[type=$:armor_stand,tag=Target,distance=..0.1] run .score Success = 1
			.if Success == 0 run .if @s.Raytrace > 0 {
				execute positioned ^ ^ ^0.1 run .recurse
			}
		}
	}
}

# as pigman in main spire room during reaction
function anger {
	execute unless data entity @s AngryAt {
		execute if entity @p[distance=..4] {
			data modify entity @s AngerTime set value 50
			data modify entity @s AngryAt set from entity @p[distance=..4] UUID
		}
	}
}


function craft {
	.define ID (BlockID[core])
	.define Item (SourceItem[core])
	.json Text {
		"text": "(Text[core])",
		"italic": false
	}
	.json NetherReactorCoreItem {
		"Item": {
			"id": "(Item)",
			"Count": 1,
			"tag": {
				"CustomModelData": (ID),
				"display": {"Name": (string[Text])}
			}
		}
	}
	kill @irons[limit=1,sort=nearest]
	kill @s
	summon $:item ~~~ (NetherReactorCoreItem)
	particle $:composter ~~~ 0.25 0.5 0.25 0.5 50 normal
}

in give {
	json ItemText {
		"text": "(Text)",
		"italic": false
	}
	for Block in (BlockNames) {
		define ID (BlockID[(Block)])
		define Item (SourceItem[(Block)])
		define Text (Text[(Block)])
		function (Block) {
			give @p (Item){CustomModelData:(ID),display:{Name:(string[ItemText])}}
		}
	}
}

structure nether_spire
function spire {
	setblock ~ ~-3 ~ minecraft:structure_block{mode:"LOAD",powered:0b,name:"~:nether_spire",posX:-8,posZ:-8}
	setblock ~ ~-2 ~ $:redstone_block
}

function decay_spire {
	.define mark loot spawn (here) loot ~:decay_rng
	# .define mark summon $:armor_stand (here) {NoGravity:true}

	# outer wall
	.range Height -1 5
	.for Y in (Height) {
		.define here ~-8 ~(Y) ~-8
		(mark)
	}
	.range Width -7 8
	.for I in (Width) {
		.eval H (I)/2 + 9
		.eval H math.ceil((H))
		.range Height -1 (H)
		.for Y in (Height) {
			.define here ~(I) ~(Y) ~-8
			(mark)
			.define here ~-8 ~(Y) ~(I)
			(mark)
		}
	}
	.range Width -7 7
	.for I in (Width) {
		.eval H (I)/2 + 17
		.eval H math.floor((H))
		.range Height -1 (H)
		.for Y in (Height) {
			.define here ~(I) ~(Y) ~8
			(mark)
			.define here ~8 ~(Y) ~(I)
			(mark)
		}
	}
	.range Height -1 20
	.for Y in (Height) {
		.define here ~8 ~(Y) ~8
		(mark)
	}

	# middle wall
	.range Height 5 22
	.for Y in (Height) {
		.define here ~-5 ~(Y) ~-5
		(mark)
	}
	.range Width -4 5
	.for I in (Width) {
		.eval H 20 - (I)/2
		.eval H math.ceil((H))
		.range Height 5 (H)
		.for Y in (Height) {
			.define here ~(I) ~(Y) ~-5
			(mark)
			.define here ~-5 ~(Y) ~(I)
			(mark)
		}
	}
	.range Width -4 0
	.for I in (Width) {
		.eval H 16 - (I)/2
		.eval H math.floor((H))
		.range Height 5 (H)
		.for Y in (Height) {
			.define here ~(I) ~(Y) ~5
			(mark)
			.define here ~5 ~(Y) ~(I)
			(mark)
		}
	}
	.range Width 1 4
	.for I in (Width) {
		.eval H 15 + (I)/2
		.eval H math.ceil((H))
		.range Height 5 (H)
		.for Y in (Height) {
			.define here ~(I) ~(Y) ~5
			(mark)
			.define here ~5 ~(Y) ~(I)
			(mark)
		}
	}
	.range Height 5 18
	.for Y in (Height) {
		.define here ~5 ~(Y) ~5
		(mark)
	}

	# inner wall
	.range Height 11 25
	.for Y in (Height) {
		.define here ~-3 ~(Y) ~-3
		(mark)
	}
	.range Width -2 3
	.for I in (Width) {
		.eval H (I)/2 + 27
		.eval H math.floor((H))
		.range Height 11 (H)
		.for Y in (Height) {
			.define here ~(I) ~(Y) ~-3
			(mark)
			.define here ~-3 ~(Y) ~(I)
			(mark)
		}
	}
	.range Width -2 2
	.for I in (Width) {
		.eval H (I)/2 + 29
		.eval H math.ceil((H))
		.range Height 11 (H)
		.for Y in (Height) {
			.define here ~(I) ~(Y) ~3
			(mark)
			.define here ~3 ~(Y) ~(I)
			(mark)
		}
	}
	.range Height 11 30
	.for Y in (Height) {
		.define here ~3 ~(Y) ~3
		(mark)
	}

	# decay at marked areas
	execute as @decayer at @s run .lambda {
		setblock ~~~ $:air replace
		kill @s
	}
}
loot decay_rng {
	"type": "command",
	"pools": [{
		"conditions": [{
			"condition": "minecraft:random_chance",
			"chance": 0.25
		}],
		"rolls": 1,
		"entries": [{
			"type": "minecraft:item",
			"name": "minecraft:netherrack",
			"functions": [{
				"function": "minecraft:set_nbt",
				"tag": "{\"decayer\":true}"
			}],
			"weight": 1
		}]
	}]
}

function infinite_night {
	.set InfiniteNightTimer run time query daytime
	.if InfiniteNightTimer >= 18000 run .if InfiniteNightTimer < 18150 run time set midnight
	.if InfiniteNightTimer < 18000 run time add 100
	.if InfiniteNightTimer >= 18150 run time add 100
}

function rng100 {
	loot spawn ~ 999 ~ loot ~:rng100
	.define @rng @item[distance=..1,nbt={Item:{tag:{rng:1b}}}]
	.score RNG = 0
	execute positioned ~ 999 ~ as @rng run .lambda {
		.set Temp run data get entity @s Item.Count
		.score RNG += Temp
		kill @s
	}
	.score Temp reset
}
loot rng100 {
	"type": "command",
	"pools": [{
		"rolls": 1,
		"entries": [{
			"type": "minecraft:item",
			"name": "minecraft:dirt",
			"functions": [
				{
					"function": "minecraft:set_count",
					"count": {
						"type": "uniform",
						"min": 0, "max": 100
					}
				},
				{
					"function": "minecraft:set_nbt",
					"tag": "{\"rng\":true}"
				}
			]
		}]
	}]
}
function rng takes RNG_Min RNG_Max {
	.call rng100
	.score RNG_Diff = RNG_Max
	.score RNG_Diff -= RNG_Min
	.score RNG_Scale = 100
	.score RNG_Scale /= RNG_Diff
	.score RNG /= RNG_Scale
	.score RNG += RNG_Min
	.score RNG < RNG_Max
	.score RNG_Diff reset
	.score RNG_Scale reset
}