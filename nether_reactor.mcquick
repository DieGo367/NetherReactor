include guise.zip

description Adds the Nether Reactor from early MCPE. By DVDo
icon nether_reactor.png

namespace minecraft
tag functions load [nether_reactor:init,guise:load]
tag functions tick [nether_reactor:tick,guise:tick]

namespace guise
declare block/place
tag functions load_blocks [nether_reactor:load_blocks]
tag functions use_hooks [nether_reactor:use_hook]
tag functions break_hooks [nether_reactor:break_hook]


namespace nether_reactor
objective NetherReactorVar

@items = @e[type=!:item]
@decayer = @items[nbt={Item:{tag:{decayer:1b}}}]
@diamonds = @items[nbt={Item:{id:"minecraft:diamond",Count:3b}}]
@irons = @items[nbt={Item:{id:"minecraft:iron_ingot",Count:6b}}]

@blocks = @e[type=!:armor_stand,tag=GuiseBlock]

enum BAR CHAT TITLE

# Custom Block Data
define core 501
define core_active 502
define core_dead 503
define glowing_obsidian 504
define CoreText {
	"text": "Nether Reactor Core",
	"italic": false
}
define CoreData {
	"CustomModelData": (core),
	"display": {
		"Name": (CoreText.string)
	}
}
define GlowingText {
	"text": "Glowing Obsidian",
	"italic": false
}
define GlowingData {
	"CustomModelData": (glowing_obsidian),
	"display": {
		"Name": (GlowingText.string)
	}
}

tag blocks reactor_base [!:cobblestone,!:blackstone]


function init {
	.score
	WarnLoc = (BAR)
	# core 
	.score Y
	.score Reaction
}

function tick {
	# crafting recipe
	> with @diamonds {
		> if ~ ~-1 ~ minecraft:crafting_table {
			> if @irons[distance=..1] run .call craft
		}
	}
	
	# core tick update
	> with @blocks[tag=ActiveCore] positioned ~ ~-0.5 ~ run .call core/reaction

	# infinite night
	> if IsInfiniteNight == 1 run .call infinite_night
}

function load_blocks {
	.define Core {
		"id": (core), "Use": true, "Break": true,
		"SourceItem": "!:diamond_ore",
		"SourceBlock": "!:spawner",
		"display": {"Name": (CoreText.string)}
	}
	.define Core_active {
		"id": (core_active), "Use": false, "Break": true,
		"SourceItem": "!:diamond_ore",
		"SourceBlock": "!:spawner",
		"display": {"Name": (CoreText.string)}
	}
	.define Core_dead {
		"id": (core_dead), "Use": false, "Break": true,
		"SourceItem": "!:diamond_ore",
		"SourceBlock": "!:spawner",
		"display": {"Name": (CoreText.string)}
	}
	.define Glowing_obsidian {
		"id": (glowing_obsidian), "Use": false, "Break": true,
		"SourceItem": "!:crying_obsidian",
		"SourceBlock": "!:crying_obsidian",
		"display": {"Name": (GlowingText.string)}
	}
	$guise:blocks.list append (Core)
	$guise:blocks.list append (Core_active)
	$guise:blocks.list append (Core_dead)
	$guise:blocks.list append (Glowing_obsidian)
}

function use_hook {
	> if ID/GuiseVar == (core) run .call core/activation_check
}

function break_hook {
	> if ID/GuiseVar >= (core) if ID/GuiseVar <= (core_dead) run .lambda {
		.call core/break
		> if Dropped/GuiseVar == 1 run loot spawn ~~~ loot ~:core
	}
	> if ID/GuiseVar == (glowing_obsidian) {
		> if Dropped/GuiseVar == 1 run loot spawn ~~~ loot ~:glowing_obsidian
	}
}
loot core {
	"type": "command",
	"pools": [{
		"rolls": 1,
		"entries": [{
			"type": "!:item", "name": "!:diamond_ore",
			"functions": [
				{"function": "!:set_nbt", "tag": (CoreData.string)}
			]
		}]
	}]
}
loot glowing_obsidian {
	"type": "command",
	"pools": [{
		"rolls": 1,
		"entries": [{
			"type": "!:item", "name": "!:crying_obsidian",
			"functions": [
				{"function": "!:set_nbt", "tag": (GlowingData.string)}
			]
		}]
	}]
}
recipe core {
	"type": "!:crafting_shaped",
	"pattern": [
		"did",
		"did",
		"did"
	],
	"key": {
		"d": {"item": "!:diamond"},
		"i": {"item": "!:iron_ingot"}
	},
	"result": {"item": "!:structure_void"}
}

# as @blocks
in core {
	function break {
		%bossbar|players clear
	}
	function activation_check {
		@s/Y = @s.Pos[1]
		> if @s/Y > 7 if @s/Y < 223 run .lambda {
			.call core/structure_check
			> if @s[tag=IsValid] run .call core/start
			> unless @s[tag=IsValid] run $warn.msg = "Not the correct pattern!"
		}
		> unless @s/Y > 7 run $warn.msg = "The nether reactor needs to be built higher up."
		> unless @s/Y < 223 run $warn.msg = "The nether reactor needs to be built lower down."
		
		> if $warn.msg run .lambda {
			> if WarnLoc == (BAR) run title @p actionbar {"text":"","extra":[{"storage":"~:warn","nbt":"msg"}]}
			> if WarnLoc == (TITLE) run title @p title {"text":"","extra":[{"storage":"~:warn","nbt":"msg"}]}
			> if WarnLoc == (CHAT) run tellraw @p {"text":"","extra":[{"storage":"~:warn","nbt":"msg"}]}
			$warn.msg remove
		}
	}
	function structure_check {
		tag @s add IsValid

		# 4 gold corners
		.for X in [-1,1] {
			.for Z in [-1,1] {
				> unless ~(X) ~-1 ~(Z) !:gold_block run tag @s remove IsValid
			}
		}
		# cobblestone plus (top and bottom)
		.for Y in [-1,1] {
			> unless ~ ~(Y) ~ #~:reactor_base run tag @s remove IsValid
			.for V in [-1,1] {
				> unless ~(V) ~(Y) ~ #~:reactor_base run tag @s remove IsValid
				> unless ~ ~(Y) ~(V) #~:reactor_base run tag @s remove IsValid
			}
		}
		# 4 cobblestone corners
		.for X in [-1,1] {
			.for Z in [-1,1] {
				> unless ~(X) ~ ~(Z) #~:reactor_base run tag @s remove IsValid
			}
		}
		# 4 air sides
		.for V in [-1,1] {
			> unless ~(V) ~ ~ #guise:air run tag @s remove IsValid
			> unless ~ ~ ~(V) #guise:air run tag @s remove IsValid
		}
		# 4 air corners
		.for X in [-1,1] {
			.for Z in [-1,1] {
				> unless ~(X) ~1 ~(Z) #guise:air run tag @s remove IsValid
			}
		}
	}
	function start {
		title @a actionbar {"text":"Active!","color":"yellow"}
		%bossbar add {"text": "Nether Reactor"}
		%bossbar|color = blue
		%bossbar|max = 920
		%bossbar = 0
		tag @s add ActiveCore
		# set red
		@s.ArmorItems[3].tag.CustomModelData = (core_active)
		IsInfiniteNight = 1
		@s/Reaction = 0
		.call spire
	}
	function reaction {
		@s/Reaction ++
		# update bossbar score
		%bossbar = @s/Reaction
		# within the main room
		> positioned ~-7.5 ~-1 ~-7.5 {
			# update bossbar player list
			%bossbar|players = @a[dx=14,dy=3,dz=14]
			# hostile pigmen
			> with @e[type=!:zombified_piglin,dx=14,dy=3,dz=14] run .call anger
		}

		# Reaction steps

		# glowing obsidian replacing cobblestone
		> if @s/Reaction == 40 run .lambda {
			ID/GuiseVar = (glowing_obsidian)
			.for X in [-1,0,1] run > positioned ~(X) ~-1 ~ run .call guise:block/place
			.for Z in [-1,1] run > positioned ~ ~-1 ~(Z) run .call guise:block/place
		}
		> if @s/Reaction == 60 run .lambda {
			ID/GuiseVar = (glowing_obsidian)
			.for X in [-1,1] {
				.for Z in [-1,1] {
					> positioned ~(X) ~ ~(Z) run .call guise:block/place
				}
			}
		}
		> if @s/Reaction == 80 run .lambda {
			ID/GuiseVar = (glowing_obsidian)
			.for X in [-1,0,1] run > positioned ~(X) ~1 ~ run .call guise:block/place
			.for Z in [-1,1] run > positioned ~ ~1 ~(Z) run .call guise:block/place
		}
		# gold is replaced
		> if @s/Reaction == 140 run .lambda {
			ID/GuiseVar = (glowing_obsidian)
			.for X in [-1,1] {
				.for Z in [-1,1] {
					> positioned ~(X) ~-1 ~(Z) run .call guise:block/place
				}
			}
		}
		# item and mob spawns
		> if @s/Reaction == 200 run .lambda {
			%bossbar|color = red
			.call core/spawns 15 15 2
		}
		> if @s/Reaction == 260 run .lambda run .call core/spawns 15 15 2
		> if @s/Reaction == 400 run .lambda run .call core/spawns 15 15 2
		> if @s/Reaction == 440 run .lambda run .call core/spawns 0 35 1
		> if @s/Reaction == 500 run .lambda run .call core/spawns 0 40 1
		> if @s/Reaction == 600 run .lambda run .call core/spawns 0 32 0
		> if @s/Reaction == 680 run .lambda run .call core/spawns 0 20 0
		> if @s/Reaction == 720 run .lambda run .call core/spawns 0 24 0
		> if @s/Reaction == 760 run .lambda run .call core/spawns 0 36 0
		> if @s/Reaction == 800 run .lambda run .call core/spawns 0 20 0
		# burning out of obsidian
		> if @s/Reaction == 860 run .lambda {
			%bossbar|color = purple
			.define Y 1.5
			.for X in [-1,0,1] run .for Z in [-1,0,1] run > positioned ~(X) ~(Y) ~(Z) run kill @blocks[distance=..0.1]
			fill ~-1 ~1 ~-1 ~1 ~1 ~1 !:obsidian
		}
		> if @s/Reaction == 880 run .lambda {
			.define Y 0.5
			.for X in [-1,0,1] run .for Z in [-1,1] run > positioned ~(X) ~(Y) ~(Z) run kill @blocks[distance=..0.1]
			.for X in [0] run .for Z in [-1,1] run > positioned ~(X) ~(Y) ~(Z) run kill @blocks[distance=..0.1]
			fill ~1 ~ ~1 ~1 ~ ~-1 !:obsidian
			fill ~-1 ~ ~1 ~-1 ~ ~-1 !:obsidian
			setblock ~ ~ ~1 !:obsidian
			setblock ~ ~ ~-1 !:obsidian
		}
		> if @s/Reaction == 900 run .lambda {
			.define Y -0.5
			.for X in [-1,0,1] run .for Z in [-1,0,1] run > positioned ~(X) ~(Y) ~(Z) run kill @blocks[distance=..0.1]
			fill ~-1 ~-1 ~-1 ~1 ~-1 ~1 !:obsidian
		}
		# end of reaction
		> if @s/Reaction >= 920 run .call core/end
	}
	function end {
		# update to dead
		tag @s remove ActiveCore
		# set black
		@s.ArmorItems[3].tag.CustomModelData = (core_dead)
		# remove bossbar
		%bossbar|players clear
		> unless @blocks[tag=ActiveCore] run bossbar remove ~:bossbar
		# remove Infinite night
		IsInfiniteNight = 0
		# structure changes
		fill ~-1 ~1 ~-1 ~1 ~1 ~1 !:obsidian
		fill ~1 ~ ~1 ~1 ~ ~-1 !:obsidian
		fill ~-1 ~ ~1 ~-1 ~ ~-1 !:obsidian
		setblock ~ ~ ~1 !:obsidian
		setblock ~ ~ ~-1 !:obsidian
		fill ~-1 ~-1 ~-1 ~1 ~-1 ~1 !:obsidian
		.call decay_spire
	}
	# Reaction functions
	function spawns takes RNG_Min RNG_Max MobLimit {
		.do rng
		ItemCount = RNG
		> positioned ~ ~-1 ~ run .call core/spawn_items
		ItemCount reset
		# locating pigmen
		> if MobLimit > 0 run .call core/spawn_mobs
		MobLimit reset
	}
	function spawn_items {
		> if ItemCount > 0 run .lambda {
			.call core/random_spot
			@spots = @e[type=!:area_effect_cloud,tag=RandomSpot]
			> at @spot run loot spawn ~~~ loot ~:rewards
			kill @spot
			ItemCount --
			> if ItemCount > 0 run .recurse
		}
	}
	function spawn_mobs {
		MobCount = 0
		> positioned ~-7.5 ~-1 ~-7.5 {
			> as @e[type=!:zombified_piglin,dx=14,dy=3,dz=14] run MobCount ++
		}
		> if MobCount < 3 run .lambda {
			.call core/spawn_mob
			MobCount ++
			MobLimit --
			> if MobCount < 3 if MobLimit > 0 run .recurse
		}
		MobCount reset
	}
	function spawn_mob {
		.call core/random_spot
		@spots = @e[type=!:area_effect_cloud,tag=RandomSpot]
		> at @spot run summon !:zombified_piglin ~~~
		kill @spot
	}
	function random_spot {
		# distance of 3 - 7 blocks, 0.5 steps
		.call rng 6 14
		Distance = RNG
		Distance ++
		# angle up to 360 degrees, 5 deg steps
		.call rng 1 72
		Angle = RNG

		> positioned ~ ~-1 ~ rotated 0 0 run .lambda {
			Angle --
			> if Angle == 0 run .lambda {
				Distance --
				> if Distance == 0 run .lambda {
					summon !:area_effect_cloud ~~~ {Duration:2}
					tag @e[type=!:area_effect_cloud,limit=1,sort=nearest] add RandomSpot
				}
				> if Distance > 0 {
					> positioned ^ ^ ^0.5 run .recurse
				}
			}
			> if Angle > 0 {
				> rotated ~5 0 run .recurse
			}
		}

		Distance reset
		Angle reset
	}
	
}
loot rewards {
	"type": "command",
	"pools": [{
		"rolls": 1,
		"entries": [
			{"type": "minecraft:item", "name": "minecraft:red_mushroom", "weight": 1},
			{"type": "minecraft:item", "name": "minecraft:brown_mushroom", "weight": 1},
			{"type": "minecraft:item", "name": "minecraft:cactus", "weight": 1},
			{
				"type": "minecraft:item", "weight": 1,
				"name": "minecraft:quartz",
				"functions": [
					{"function": "minecraft:set_count", "count": 4}
				]
			},
			{"type": "minecraft:item", "name": "minecraft:sugar_cane", "weight": 1},
			{
				"type": "minecraft:item", "weight": 1,
				"name": "minecraft:glowstone_dust",
				"functions": [
					{"function": "minecraft:set_count", "count": 3}
				]
			},
			{"type": "minecraft:item", "name": "minecraft:pumpkin_seeds", "weight": 1},
			{"type": "minecraft:item", "name": "minecraft:melon_seeds", "weight": 1}
		]
	}]
}


# as pigman in main spire room during reaction
function anger {
	> unless @s.AngryAt {
		> if @p[distance=..4] {
			@s.AngerTime = 50
			@s.AngryAt = @p[distance=..4].UUID
		}
	}
}


function craft {
	kill @iron
	kill @s
	loot spawn ~~~ loot ~:core
	particle !:composter ~~~ 0.25 0.5 0.25 0.5 50 normal
}

structure nether_spire
function spire {
	setblock ~ ~-3 ~ minecraft:structure_block{mode:"LOAD",powered:0b,name:"~:nether_spire",posX:-8,posZ:-8}
	setblock ~ ~-2 ~ !:redstone_block
}

function decay_spire {
	# outer wall
	.eval Height range(-1, 6)
	.for Y in (Height) {
		loot spawn ~-8 ~(Y) ~-8 loot ~:decay_rng
	}
	.eval Width range(-7, 9)
	.for I in (Width) {
		.eval H (I)/2 + 9
		.eval H math.ceil((H))
		.eval Height range(-1, (H)+1)
		.for Y in (Height) {
			loot spawn ~(I) ~(Y) ~-8 loot ~:decay_rng
			loot spawn ~-8 ~(Y) ~(I) loot ~:decay_rng
		}
	}
	.eval Width range(-7, 8)
	.for I in (Width) {
		.eval H (I)/2 + 17
		.eval H math.floor((H))
		.eval Height range(-1, (H)+1)
		.for Y in (Height) {
			loot spawn ~(I) ~(Y) ~8 loot ~:decay_rng
			loot spawn ~8 ~(Y) ~(I) loot ~:decay_rng
		}
	}
	.eval Height range(-1, 21)
	.for Y in (Height) {
		loot spawn ~8 ~(Y) ~8 loot ~:decay_rng
	}

	# middle wall
	.eval Height range(5, 23)
	.for Y in (Height) {
		loot spawn ~-5 ~(Y) ~-5 loot ~:decay_rng
	}
	.eval Width range(-4, 6)
	.for I in (Width) {
		.eval H 20 - (I)/2
		.eval H math.ceil((H))
		.eval Height range(5, (H)+1)
		.for Y in (Height) {
			loot spawn ~(I) ~(Y) ~-5 loot ~:decay_rng
			loot spawn ~-5 ~(Y) ~(I) loot ~:decay_rng
		}
	}
	.eval Width range(-4, 1)
	.for I in (Width) {
		.eval H 16 - (I)/2
		.eval H math.floor((H))
		.eval Height range(5, (H)+1)
		.for Y in (Height) {
			loot spawn ~(I) ~(Y) ~5 loot ~:decay_rng
			loot spawn ~5 ~(Y) ~(I) loot ~:decay_rng
		}
	}
	.eval Width range(1, 5)
	.for I in (Width) {
		.eval H 15 + (I)/2
		.eval H math.ceil((H))
		.eval Height range(5, (H)+1)
		.for Y in (Height) {
			loot spawn ~(I) ~(Y) ~5 loot ~:decay_rng
			loot spawn ~5 ~(Y) ~(I) loot ~:decay_rng
		}
	}
	.eval Height range(5, 19)
	.for Y in (Height) {
		loot spawn ~5 ~(Y) ~5 loot ~:decay_rng
	}

	# inner wall
	.eval Height range(11, 26)
	.for Y in (Height) {
		loot spawn ~-3 ~(Y) ~-3 loot ~:decay_rng
	}
	.eval Width range(-2, 4)
	.for I in (Width) {
		.eval H (I)/2 + 27
		.eval H math.floor((H))
		.eval Height range(11, (H)+1)
		.for Y in (Height) {
			loot spawn ~(I) ~(Y) ~-3 loot ~:decay_rng
			loot spawn ~-3 ~(Y) ~(I) loot ~:decay_rng
		}
	}
	.eval Width range(-2, 3)
	.for I in (Width) {
		.eval H (I)/2 + 29
		.eval H math.ceil((H))
		.eval Height range(11, (H)+1)
		.for Y in (Height) {
			loot spawn ~(I) ~(Y) ~3 loot ~:decay_rng
			loot spawn ~3 ~(Y) ~(I) loot ~:decay_rng
		}
	}
	.eval Height range(11, 31)
	.for Y in (Height) {
		loot spawn ~3 ~(Y) ~3 loot ~:decay_rng
	}

	# decay at marked areas
	> with @decayer run .lambda {
		setblock ~~~ !:air replace
		kill @s
	}
}
loot decay_rng {
	"type": "command",
	"pools": [{
		"conditions": [{
			"condition": "minecraft:random_chance",
			"chance": 0.25
		}],
		"rolls": 1,
		"entries": [{
			"type": "minecraft:item",
			"name": "minecraft:netherrack",
			"functions": [{
				"function": "minecraft:set_nbt",
				"tag": "{\"decayer\":true}"
			}],
			"weight": 1
		}]
	}]
}

function infinite_night {
	> store result InfiniteNightTimer run time query daytime
	> if InfiniteNightTimer >= 18000 if InfiniteNightTimer < 18150 run /time set midnight
	> if InfiniteNightTimer < 18000 run time add 100
	> if InfiniteNightTimer >= 18150 run time add 100
}

function rng100 {
	loot spawn ~ 999 ~ loot ~:rng100
	@rng = @item[distance=..1,nbt={Item:{tag:{rng:1b}}}]
	RNG = 0
	> positioned ~ 999 ~ as @rng run .lambda {
		Temp = @s.Item.Count
		RNG += Temp
		kill @s
	}
	Temp reset
}
loot rng100 {
	"type": "command",
	"pools": [{
		"rolls": 1,
		"entries": [{
			"type": "minecraft:item",
			"name": "minecraft:dirt",
			"functions": [
				{
					"function": "minecraft:set_count",
					"count": {
						"type": "uniform",
						"min": 0, "max": 100
					}
				},
				{
					"function": "minecraft:set_nbt",
					"tag": "{\"rng\":true}"
				}
			]
		}]
	}]
}
function rng takes RNG_Min RNG_Max {
	.call rng100
	RNG_Diff = RNG_Max
	RNG_Diff -= RNG_Min
	RNG_Scale = 100
	RNG_Scale /= RNG_Diff
	RNG /= RNG_Scale
	RNG += RNG_Min
	RNG < RNG_Max
	RNG_Diff reset
	RNG_Scale reset
}